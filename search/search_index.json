{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dolo Introduction Dolo is a tool to describe and solve economic models. It provides a simple classification scheme to describe many types of models, allows to write the models as simple text files and compiles these files into efficient Python objects representing them. It also provides many reference solution algorithms to find the solution of these models under rational expectations. Dolo understand several types of nonlinear models with occasionnally binding constraints (with or without exogenous discrete shocks), as well as local pertubations models, like Dynare. It is a very adequate tool to study zero-lower bound issues, or sudden-stop problems, for instance. Sophisticated solution routines are available: local perturbations up to third order, perfect foresight solution, policy iteration, value iteration. Most of these solutions are either parallelized or vectorized. They are written in pure Python, and can easily be inspected or adapted. Thanks to the simple and consistent Python API for models, it is possible to write models in pure Python, or to implement other solution algorithms on top it. Frequently Asked Questions No question was ever asked. Certainly because it's all very clear.","title":"Home"},{"location":"#dolo","text":"","title":"Dolo"},{"location":"#introduction","text":"Dolo is a tool to describe and solve economic models. It provides a simple classification scheme to describe many types of models, allows to write the models as simple text files and compiles these files into efficient Python objects representing them. It also provides many reference solution algorithms to find the solution of these models under rational expectations. Dolo understand several types of nonlinear models with occasionnally binding constraints (with or without exogenous discrete shocks), as well as local pertubations models, like Dynare. It is a very adequate tool to study zero-lower bound issues, or sudden-stop problems, for instance. Sophisticated solution routines are available: local perturbations up to third order, perfect foresight solution, policy iteration, value iteration. Most of these solutions are either parallelized or vectorized. They are written in pure Python, and can easily be inspected or adapted. Thanks to the simple and consistent Python API for models, it is possible to write models in pure Python, or to implement other solution algorithms on top it.","title":"Introduction"},{"location":"#frequently-asked-questions","text":"No question was ever asked. Certainly because it's all very clear.","title":"Frequently Asked Questions"},{"location":"installation/","text":"Basic installation Dolo can be installed in several ways: with anaconda (recommended): conda install -c conda-forge dolo with pip pip install dolo Developper's installation Dolo uses poetry as package manager, so you probably need to install poetry before you start developing the package.","title":"Install"},{"location":"installation/#basic-installation","text":"Dolo can be installed in several ways: with anaconda (recommended): conda install -c conda-forge dolo with pip pip install dolo","title":"Basic installation"},{"location":"installation/#developpers-installation","text":"Dolo uses poetry as package manager, so you probably need to install poetry before you start developing the package.","title":"Developper's installation"},{"location":"api/dolo.algos.improved_time_iteration/","text":"module dolo.algos . improved_time_iteration </> Do I need a docstring here ? Classes Operator \u2014 Special Linear Operator </> class dolo.algos.improved_time_iteration . Operator ( *args , **kwargs ) </> Bases scipy.sparse.linalg.interface.LinearOperator Special Linear Operator Attributes adjoint \u2014 Hermitian adjoint. Returns the Hermitian adjoint of self, aka the Hermitian conjugate or Hermitian transpose. For a complex matrix, the Hermitian adjoint is equal to the conjugate transpose. Can be abbreviated self.H instead of self.adjoint(). </> args (tuple) \u2014 For linear operators describing products etc. of other linear operators, the operands of the binary operation. transpose \u2014 Transpose this linear operator. Returns a LinearOperator that represents the transpose of this one. Can be abbreviated self.T instead of self.transpose(). </> Methods adjoint ( ) (A_H : LinearOperator) \u2014 Hermitian adjoint. </> dot ( x ) (Ax : array) \u2014 Matrix-matrix or matrix-vector multiplication. </> matmat ( X ) (Y : {matrix, ndarray}) \u2014 Matrix-matrix multiplication. </> matvec ( x ) (y : {matrix, ndarray}) \u2014 Matrix-vector multiplication. </> rmatmat ( X ) (Y : {matrix, ndarray}) \u2014 Adjoint matrix-matrix multiplication. </> rmatvec ( x ) (y : {matrix, ndarray}) \u2014 Adjoint matrix-vector multiplication. </> transpose ( ) \u2014 Transpose this linear operator. </> method matvec ( x ) </> Matrix-vector multiplication. Performs the operation y=A*x where A is an MxN linear operator and x is a column vector or 1-d array. Parameters x ({matrix, ndarray}) \u2014 An array with shape (N,) or (N,1). Returns (y : {matrix, ndarray}) A matrix or ndarray with shape (M,) or (M,1) depending on the type and shape of the x argument. Notes This matvec wraps the user-specified matvec routine or overridden _matvec method to ensure that y has the correct shape and type. method rmatvec ( x ) </> Adjoint matrix-vector multiplication. Performs the operation y = A^H * x where A is an MxN linear operator and x is a column vector or 1-d array. Parameters x ({matrix, ndarray}) \u2014 An array with shape (M,) or (M,1). Returns (y : {matrix, ndarray}) A matrix or ndarray with shape (N,) or (N,1) depending on the type and shape of the x argument. Notes This rmatvec wraps the user-specified rmatvec routine or overridden _rmatvec method to ensure that y has the correct shape and type. method matmat ( X ) </> Matrix-matrix multiplication. Performs the operation y=A X where A is an MxN linear operator and X dense N K matrix or ndarray. Parameters X ({matrix, ndarray}) \u2014 An array with shape (N,K). Returns (Y : {matrix, ndarray}) A matrix or ndarray with shape (M,K) depending on the type of the X argument. Notes This matmat wraps any user-specified matmat routine or overridden _matmat method to ensure that y has the correct type. method rmatmat ( X ) </> Adjoint matrix-matrix multiplication. Performs the operation y = A^H * x where A is an MxN linear operator and x is a column vector or 1-d array, or 2-d array. The default implementation defers to the adjoint. Parameters X ({matrix, ndarray}) \u2014 A matrix or 2D array. Returns (Y : {matrix, ndarray}) A matrix or 2D array depending on the type of the input. Notes This rmatmat wraps the user-specified rmatmat routine. method dot ( x ) </> Matrix-matrix or matrix-vector multiplication. Parameters x (array_like) \u2014 1-d or 2-d array, representing a vector or matrix. Returns (Ax : array) 1-d or 2-d array (depending on the shape of x) that represents the result of applying this linear operator on x. method adjoint ( ) </> Hermitian adjoint. Returns the Hermitian adjoint of self, aka the Hermitian conjugate or Hermitian transpose. For a complex matrix, the Hermitian adjoint is equal to the conjugate transpose. Can be abbreviated self.H instead of self.adjoint(). Returns (A_H : LinearOperator) Hermitian adjoint of self. method transpose ( ) </> Transpose this linear operator. Returns a LinearOperator that represents the transpose of this one. Can be abbreviated self.T instead of self.transpose().","title":"dolo.algos.improved_time_iteration"},{"location":"api/dolo.algos.improved_time_iteration/#doloalgosimproved_time_iteration","text":"</> Do I need a docstring here ? Classes Operator \u2014 Special Linear Operator </> class","title":"dolo.algos.improved_time_iteration"},{"location":"api/dolo.algos.improved_time_iteration/#doloalgosimproved_time_iterationoperator","text":"</> Bases scipy.sparse.linalg.interface.LinearOperator Special Linear Operator Attributes adjoint \u2014 Hermitian adjoint. Returns the Hermitian adjoint of self, aka the Hermitian conjugate or Hermitian transpose. For a complex matrix, the Hermitian adjoint is equal to the conjugate transpose. Can be abbreviated self.H instead of self.adjoint(). </> args (tuple) \u2014 For linear operators describing products etc. of other linear operators, the operands of the binary operation. transpose \u2014 Transpose this linear operator. Returns a LinearOperator that represents the transpose of this one. Can be abbreviated self.T instead of self.transpose(). </> Methods adjoint ( ) (A_H : LinearOperator) \u2014 Hermitian adjoint. </> dot ( x ) (Ax : array) \u2014 Matrix-matrix or matrix-vector multiplication. </> matmat ( X ) (Y : {matrix, ndarray}) \u2014 Matrix-matrix multiplication. </> matvec ( x ) (y : {matrix, ndarray}) \u2014 Matrix-vector multiplication. </> rmatmat ( X ) (Y : {matrix, ndarray}) \u2014 Adjoint matrix-matrix multiplication. </> rmatvec ( x ) (y : {matrix, ndarray}) \u2014 Adjoint matrix-vector multiplication. </> transpose ( ) \u2014 Transpose this linear operator. </> method","title":"dolo.algos.improved_time_iteration.Operator"},{"location":"api/dolo.algos.improved_time_iteration/#scipysparselinalginterfacelinearoperatormatvec","text":"</> Matrix-vector multiplication. Performs the operation y=A*x where A is an MxN linear operator and x is a column vector or 1-d array. Parameters x ({matrix, ndarray}) \u2014 An array with shape (N,) or (N,1). Returns (y : {matrix, ndarray}) A matrix or ndarray with shape (M,) or (M,1) depending on the type and shape of the x argument. Notes This matvec wraps the user-specified matvec routine or overridden _matvec method to ensure that y has the correct shape and type. method","title":"scipy.sparse.linalg.interface.LinearOperator.matvec"},{"location":"api/dolo.algos.improved_time_iteration/#scipysparselinalginterfacelinearoperatorrmatvec","text":"</> Adjoint matrix-vector multiplication. Performs the operation y = A^H * x where A is an MxN linear operator and x is a column vector or 1-d array. Parameters x ({matrix, ndarray}) \u2014 An array with shape (M,) or (M,1). Returns (y : {matrix, ndarray}) A matrix or ndarray with shape (N,) or (N,1) depending on the type and shape of the x argument. Notes This rmatvec wraps the user-specified rmatvec routine or overridden _rmatvec method to ensure that y has the correct shape and type. method","title":"scipy.sparse.linalg.interface.LinearOperator.rmatvec"},{"location":"api/dolo.algos.improved_time_iteration/#scipysparselinalginterfacelinearoperatormatmat","text":"</> Matrix-matrix multiplication. Performs the operation y=A X where A is an MxN linear operator and X dense N K matrix or ndarray. Parameters X ({matrix, ndarray}) \u2014 An array with shape (N,K). Returns (Y : {matrix, ndarray}) A matrix or ndarray with shape (M,K) depending on the type of the X argument. Notes This matmat wraps any user-specified matmat routine or overridden _matmat method to ensure that y has the correct type. method","title":"scipy.sparse.linalg.interface.LinearOperator.matmat"},{"location":"api/dolo.algos.improved_time_iteration/#scipysparselinalginterfacelinearoperatorrmatmat","text":"</> Adjoint matrix-matrix multiplication. Performs the operation y = A^H * x where A is an MxN linear operator and x is a column vector or 1-d array, or 2-d array. The default implementation defers to the adjoint. Parameters X ({matrix, ndarray}) \u2014 A matrix or 2D array. Returns (Y : {matrix, ndarray}) A matrix or 2D array depending on the type of the input. Notes This rmatmat wraps the user-specified rmatmat routine. method","title":"scipy.sparse.linalg.interface.LinearOperator.rmatmat"},{"location":"api/dolo.algos.improved_time_iteration/#scipysparselinalginterfacelinearoperatordot","text":"</> Matrix-matrix or matrix-vector multiplication. Parameters x (array_like) \u2014 1-d or 2-d array, representing a vector or matrix. Returns (Ax : array) 1-d or 2-d array (depending on the shape of x) that represents the result of applying this linear operator on x. method","title":"scipy.sparse.linalg.interface.LinearOperator.dot"},{"location":"api/dolo.algos.improved_time_iteration/#scipysparselinalginterfacelinearoperatoradjoint","text":"</> Hermitian adjoint. Returns the Hermitian adjoint of self, aka the Hermitian conjugate or Hermitian transpose. For a complex matrix, the Hermitian adjoint is equal to the conjugate transpose. Can be abbreviated self.H instead of self.adjoint(). Returns (A_H : LinearOperator) Hermitian adjoint of self. method","title":"scipy.sparse.linalg.interface.LinearOperator.adjoint"},{"location":"api/dolo.algos.improved_time_iteration/#scipysparselinalginterfacelinearoperatortranspose","text":"</> Transpose this linear operator. Returns a LinearOperator that represents the transpose of this one. Can be abbreviated self.T instead of self.transpose().","title":"scipy.sparse.linalg.interface.LinearOperator.transpose"},{"location":"api/dolo.algos/","text":"package dolo . algos </> All kinds of algorithms. module dolo.algos . improved_time_iteration </> Do I need a docstring here ? Classes Operator \u2014 Special Linear Operator </> module dolo.algos . time_iteration </> Time Iteration Algorithm Functions time_iteration ( model , dr0 , with_complementarities , verbose , maxit , inner_maxit , tol , hook , details , interp_method ) (decision rule :) \u2014 Finds a global solution for model using backward time-iteration. </>","title":"dolo.algos"},{"location":"api/dolo.algos/#doloalgos","text":"</> All kinds of algorithms. module","title":"dolo.algos"},{"location":"api/dolo.algos/#doloalgosimproved_time_iteration","text":"</> Do I need a docstring here ? Classes Operator \u2014 Special Linear Operator </> module","title":"dolo.algos.improved_time_iteration"},{"location":"api/dolo.algos/#doloalgostime_iteration","text":"</> Time Iteration Algorithm Functions time_iteration ( model , dr0 , with_complementarities , verbose , maxit , inner_maxit , tol , hook , details , interp_method ) (decision rule :) \u2014 Finds a global solution for model using backward time-iteration. </>","title":"dolo.algos.time_iteration"},{"location":"api/dolo.algos.time_iteration/","text":"module dolo.algos . time_iteration </> Time Iteration Algorithm Functions time_iteration ( model , dr0 , with_complementarities , verbose , maxit , inner_maxit , tol , hook , details , interp_method ) (decision rule :) \u2014 Finds a global solution for model using backward time-iteration. </> function dolo.algos.time_iteration . time_iteration ( model , dr0=None , with_complementarities=True , verbose=True , maxit=1000 , inner_maxit=10 , tol=1e-06 , hook=None , details=False , interp_method='cubic' ) </> Finds a global solution for model using backward time-iteration. This algorithm iterates on the residuals of the arbitrage equations Parameters model (Model) \u2014 model to be solved dr0 (decision rule) \u2014 initial guess for the decision rule with_complementarities (boolean (True)) \u2014 if False, complementarity conditions are ignored verbose (boolean) \u2014 if True, display iterations hook (Callable) \u2014 function to be called within each iteration, useful for debugging purposes Returns (decision rule :) approximated solution","title":"dolo.algos.time_iteration"},{"location":"api/dolo.algos.time_iteration/#doloalgostime_iteration","text":"</> Time Iteration Algorithm Functions time_iteration ( model , dr0 , with_complementarities , verbose , maxit , inner_maxit , tol , hook , details , interp_method ) (decision rule :) \u2014 Finds a global solution for model using backward time-iteration. </> function","title":"dolo.algos.time_iteration"},{"location":"api/dolo.algos.time_iteration/#doloalgostime_iterationtime_iteration","text":"</> Finds a global solution for model using backward time-iteration. This algorithm iterates on the residuals of the arbitrage equations Parameters model (Model) \u2014 model to be solved dr0 (decision rule) \u2014 initial guess for the decision rule with_complementarities (boolean (True)) \u2014 if False, complementarity conditions are ignored verbose (boolean) \u2014 if True, display iterations hook (Callable) \u2014 function to be called within each iteration, useful for debugging purposes Returns (decision rule :) approximated solution","title":"dolo.algos.time_iteration.time_iteration"},{"location":"api/dolo.compiler/","text":"package dolo . compiler </> module dolo.compiler . recipes </> ideas : - recursive blocks [by default] - (order left hand side ?) [by default] - dependency across blocks - dummy blocks that are basically substituted everywhere else","title":"dolo.compiler"},{"location":"api/dolo.compiler/#dolocompiler","text":"</> module","title":"dolo.compiler"},{"location":"api/dolo.compiler/#dolocompilerrecipes","text":"</> ideas : - recursive blocks [by default] - (order left hand side ?) [by default] - dependency across blocks - dummy blocks that are basically substituted everywhere else","title":"dolo.compiler.recipes"},{"location":"api/dolo.compiler.recipes/","text":"module dolo.compiler . recipes </> ideas : - recursive blocks [by default] - (order left hand side ?) [by default] - dependency across blocks - dummy blocks that are basically substituted everywhere else","title":"dolo.compiler.recipes"},{"location":"api/dolo.compiler.recipes/#dolocompilerrecipes","text":"</> ideas : - recursive blocks [by default] - (order left hand side ?) [by default] - dependency across blocks - dummy blocks that are basically substituted everywhere else","title":"dolo.compiler.recipes"},{"location":"api/dolo/","text":"package dolo </> package dolo . algos </> All kinds of algorithms.","title":"dolo"},{"location":"api/dolo/#dolo","text":"</> package","title":"dolo"},{"location":"api/dolo/#doloalgos","text":"</> All kinds of algorithms.","title":"dolo.algos"},{"location":"api/dolo.misc/","text":"package dolo . misc </> module dolo.misc . termcolor </> ANSII Color formatting for output in terminal. Functions colored ( text , color , on_color , attrs ) \u2014 Colorize text. </> cprint ( text , color , on_color , attrs , **kwargs ) \u2014 Print colorize text. </>","title":"dolo.misc"},{"location":"api/dolo.misc/#dolomisc","text":"</> module","title":"dolo.misc"},{"location":"api/dolo.misc/#dolomisctermcolor","text":"</> ANSII Color formatting for output in terminal. Functions colored ( text , color , on_color , attrs ) \u2014 Colorize text. </> cprint ( text , color , on_color , attrs , **kwargs ) \u2014 Print colorize text. </>","title":"dolo.misc.termcolor"},{"location":"api/dolo.misc.termcolor/","text":"module dolo.misc . termcolor </> ANSII Color formatting for output in terminal. Functions colored ( text , color , on_color , attrs ) \u2014 Colorize text. </> cprint ( text , color , on_color , attrs , **kwargs ) \u2014 Print colorize text. </> function dolo.misc.termcolor . colored ( text , color=None , on_color=None , attrs=None ) </> Colorize text. Available text colors: red, green, yellow, blue, magenta, cyan, white. Available text highlights: on_red, on_green, on_yellow, on_blue, on_magenta, on_cyan, on_white. Available attributes: bold, dark, underline, blink, reverse, concealed. Example colored('Hello, World!', 'red', 'on_grey', ['blue', 'blink']) colored('Hello, World!', 'green') function dolo.misc.termcolor . cprint ( text , color=None , on_color=None , attrs=None , **kwargs ) </> Print colorize text. It accepts arguments of print function.","title":"dolo.misc.termcolor"},{"location":"api/dolo.misc.termcolor/#dolomisctermcolor","text":"</> ANSII Color formatting for output in terminal. Functions colored ( text , color , on_color , attrs ) \u2014 Colorize text. </> cprint ( text , color , on_color , attrs , **kwargs ) \u2014 Print colorize text. </> function","title":"dolo.misc.termcolor"},{"location":"api/dolo.misc.termcolor/#dolomisctermcolorcolored","text":"</> Colorize text. Available text colors: red, green, yellow, blue, magenta, cyan, white. Available text highlights: on_red, on_green, on_yellow, on_blue, on_magenta, on_cyan, on_white. Available attributes: bold, dark, underline, blink, reverse, concealed. Example colored('Hello, World!', 'red', 'on_grey', ['blue', 'blink']) colored('Hello, World!', 'green') function","title":"dolo.misc.termcolor.colored"},{"location":"api/dolo.misc.termcolor/#dolomisctermcolorcprint","text":"</> Print colorize text. It accepts arguments of print function.","title":"dolo.misc.termcolor.cprint"},{"location":"api/dolo.numeric.discretization.discretization/","text":"module dolo.numeric.discretization . discretization </> Discretization of continuous processes as markov chain Functions multidimensional_discretization ( rho , sigma , N , method , m ) \u2014 Discretize an VAR(1) into a markov chain. The autoregression matrix is supposed to be a scalar. </> rouwenhorst ( rho , sigma , N ) \u2014 Approximate an AR1 process by a finite markov chain using Rouwenhorst's method. </> tauchen ( N , mu , rho , sigma , m ) \u2014 Approximate an AR1 process by a finite markov chain using Tauchen's method. </> tensor_markov ( *args ) \u2014 Computes the product of two independent markov chains. </> function dolo.numeric.discretization.discretization . tauchen ( N , mu , rho , sigma , m=2 ) </> Approximate an AR1 process by a finite markov chain using Tauchen's method. :param N: scalar, number of nodes for Z :param mu: scalar, unconditional mean of process :param rho: scalar :param sigma: scalar, std. dev. of epsilons :param m: max +- std. devs. :returns: Z, N 1 vector, nodes for Z. Zprob, N N matrix, transition probabilities SJB: This is a port of Martin Floden's 1996 Matlab code to implement Tauchen 1986 Economic Letters method The following comments are Floden's. Finds a Markov chain whose sample paths approximate those of the AR(1) process z(t+1) = (1-rho)*mu + rho * z(t) + eps(t+1) where eps are normal with stddev sigma. function dolo.numeric.discretization.discretization . rouwenhorst ( rho , sigma , N ) </> Approximate an AR1 process by a finite markov chain using Rouwenhorst's method. :param rho: autocorrelation of the AR1 process :param sigma: conditional standard deviation of the AR1 process :param N: number of states :return [nodes, P]: equally spaced nodes and transition matrix function dolo.numeric.discretization.discretization . multidimensional_discretization ( rho , sigma , N=3 , method='rouwenhorst' , m=2 ) </> Discretize an VAR(1) into a markov chain. The autoregression matrix is supposed to be a scalar. :param rho: :param sigma: :param N: :param method: :param m: :return: function dolo.numeric.discretization.discretization . tensor_markov ( *args ) </> Computes the product of two independent markov chains. :param m1: a tuple containing the nodes and the transition matrix of the first chain :param m2: a tuple containing the nodes and the transition matrix of the second chain :return: a tuple containing the nodes and the transition matrix of the product chain","title":"dolo.numeric.discretization.discretization"},{"location":"api/dolo.numeric.discretization.discretization/#dolonumericdiscretizationdiscretization","text":"</> Discretization of continuous processes as markov chain Functions multidimensional_discretization ( rho , sigma , N , method , m ) \u2014 Discretize an VAR(1) into a markov chain. The autoregression matrix is supposed to be a scalar. </> rouwenhorst ( rho , sigma , N ) \u2014 Approximate an AR1 process by a finite markov chain using Rouwenhorst's method. </> tauchen ( N , mu , rho , sigma , m ) \u2014 Approximate an AR1 process by a finite markov chain using Tauchen's method. </> tensor_markov ( *args ) \u2014 Computes the product of two independent markov chains. </> function","title":"dolo.numeric.discretization.discretization"},{"location":"api/dolo.numeric.discretization.discretization/#dolonumericdiscretizationdiscretizationtauchen","text":"</> Approximate an AR1 process by a finite markov chain using Tauchen's method. :param N: scalar, number of nodes for Z :param mu: scalar, unconditional mean of process :param rho: scalar :param sigma: scalar, std. dev. of epsilons :param m: max +- std. devs. :returns: Z, N 1 vector, nodes for Z. Zprob, N N matrix, transition probabilities SJB: This is a port of Martin Floden's 1996 Matlab code to implement Tauchen 1986 Economic Letters method The following comments are Floden's. Finds a Markov chain whose sample paths approximate those of the AR(1) process z(t+1) = (1-rho)*mu + rho * z(t) + eps(t+1) where eps are normal with stddev sigma. function","title":"dolo.numeric.discretization.discretization.tauchen"},{"location":"api/dolo.numeric.discretization.discretization/#dolonumericdiscretizationdiscretizationrouwenhorst","text":"</> Approximate an AR1 process by a finite markov chain using Rouwenhorst's method. :param rho: autocorrelation of the AR1 process :param sigma: conditional standard deviation of the AR1 process :param N: number of states :return [nodes, P]: equally spaced nodes and transition matrix function","title":"dolo.numeric.discretization.discretization.rouwenhorst"},{"location":"api/dolo.numeric.discretization.discretization/#dolonumericdiscretizationdiscretizationmultidimensional_discretization","text":"</> Discretize an VAR(1) into a markov chain. The autoregression matrix is supposed to be a scalar. :param rho: :param sigma: :param N: :param method: :param m: :return: function","title":"dolo.numeric.discretization.discretization.multidimensional_discretization"},{"location":"api/dolo.numeric.discretization.discretization/#dolonumericdiscretizationdiscretizationtensor_markov","text":"</> Computes the product of two independent markov chains. :param m1: a tuple containing the nodes and the transition matrix of the first chain :param m2: a tuple containing the nodes and the transition matrix of the second chain :return: a tuple containing the nodes and the transition matrix of the product chain","title":"dolo.numeric.discretization.discretization.tensor_markov"},{"location":"api/dolo.numeric.discretization/","text":"package dolo.numeric . discretization </> module dolo.numeric.discretization . discretization </> Discretization of continuous processes as markov chain Functions multidimensional_discretization ( rho , sigma , N , method , m ) \u2014 Discretize an VAR(1) into a markov chain. The autoregression matrix is supposed to be a scalar. </> rouwenhorst ( rho , sigma , N ) \u2014 Approximate an AR1 process by a finite markov chain using Rouwenhorst's method. </> tauchen ( N , mu , rho , sigma , m ) \u2014 Approximate an AR1 process by a finite markov chain using Tauchen's method. </> tensor_markov ( *args ) \u2014 Computes the product of two independent markov chains. </>","title":"dolo.numeric.discretization"},{"location":"api/dolo.numeric.discretization/#dolonumericdiscretization","text":"</> module","title":"dolo.numeric.discretization"},{"location":"api/dolo.numeric.discretization/#dolonumericdiscretizationdiscretization","text":"</> Discretization of continuous processes as markov chain Functions multidimensional_discretization ( rho , sigma , N , method , m ) \u2014 Discretize an VAR(1) into a markov chain. The autoregression matrix is supposed to be a scalar. </> rouwenhorst ( rho , sigma , N ) \u2014 Approximate an AR1 process by a finite markov chain using Rouwenhorst's method. </> tauchen ( N , mu , rho , sigma , m ) \u2014 Approximate an AR1 process by a finite markov chain using Tauchen's method. </> tensor_markov ( *args ) \u2014 Computes the product of two independent markov chains. </>","title":"dolo.numeric.discretization.discretization"},{"location":"api/source/dolo.algos.improved_time_iteration/","text":"SOURCE CODE dolo.algos. improved_time_iteration DOCS \"\"\"Do I need a docstring here ?\"\"\" from .bruteforce_lib import * from .invert import * from dolo.numeric.decision_rule import DecisionRule from dolo.misc.itprinter import IterationsPrinter from numba import jit import numpy import time import scipy.sparse.linalg from operator import mul from functools import reduce from dolo.numeric.optimize.newton import SerialDifferentiableFunction def prod ( l ): return reduce ( mul , l ) from math import sqrt from numba import jit import time from numpy import array , zeros import time @jit def inplace ( Phi , J ): a , b , c , d , e = J . shape for i_a in range ( a ): for i_b in range ( b ): for i_c in range ( c ): for i_d in range ( d ): for i_e in range ( e ): J [ i_a , i_b , i_c , i_d , i_e ] *= Phi [ i_a , i_c , i_d ] def smooth ( res , dres , jres , dx , pos = 1.0 ): from numpy import sqrt # jres is modified dinf = dx > 100000 n_m , N , n_x = res . shape sq = sqrt ( res ** 2 + ( dx ) ** 2 ) H = res + ( dx ) - sq Phi_a = 1 - res / sq Phi_b = 1 - ( dx ) / sq H [ dinf ] = res [ dinf ] Phi_a [ dinf ] = 1.0 Phi_b [ dinf ] = 0.0 H_x = Phi_a [:,:,:, None ] * dres for i_x in range ( n_x ): H_x [:,:, i_x , i_x ] += Phi_b [:,:, i_x ] * pos # H_xt = Phi_a[:,None,:,:,None]*jres inplace ( Phi_a , jres ) return H , H_x , jres # return H, H_x, H_xt def smooth_nodiff ( res , dx ): from numpy import sqrt n_m , N , n_x = res . shape dinf = dx > 100000 sq = sqrt ( res ** 2 + ( dx ) ** 2 ) H = res + ( dx ) - sq H [ dinf ] = res [ dinf ] return H @jit def ssmul ( A , B ): # simple serial_mult (matrix times vector) N , a , b = A . shape NN , b = B . shape O = numpy . zeros (( N , a )) for n in range ( N ): for k in range ( a ): for l in range ( b ): O [ n , k ] += A [ n , k , l ] * B [ n , l ] return O @jit def ssmul_inplace ( A , B , O ): # simple serial_mult (matrix times vector) N , a , b = A . shape NN , b = B . shape # O = numpy.zeros((N,a)) for n in range ( N ): for k in range ( a ): for l in range ( b ): O [ n , k ] += A [ n , k , l ] * B [ n , l ] return O # make parallel using guvectorize ? def d_filt_dx ( \u03c0 , M_ij , S_ij , n_m , N , n_x , dumdr ): # OK, so res is probably not what we need to filter here. #s sh n_m , n_im = M_ij . shape [: 2 ] dumdr . set_values ( \u03c0 ) i = 0 j = 0 for i in range ( n_m ): \u03c0 [ i ,:,:] = 0 for j in range ( n_im ): A = M_ij [ i , j ,:,:,:] B = dumdr . eval_ijs ( i , j , S_ij [ i , j ,:,:]) \u03c0 [ i ,:,:] += ssmul ( A , B ) return \u03c0 from scipy.sparse.linalg import LinearOperator class Operator ( LinearOperator ): DOCS \"\"\"Special Linear Operator\"\"\" def __init__ ( self , M_ij , S_ij , dumdr ): self . M_ij = M_ij self . S_ij = S_ij self . n_m = M_ij . shape [ 0 ] self . N = M_ij . shape [ 2 ] self . n_x = M_ij . shape [ 3 ] self . dumdr = dumdr self . dtype = numpy . dtype ( 'float64' ) self . counter = 0 self . addid = False @property def shape ( self ): nn = self . n_m * self . N * self . n_x return ( nn , nn ) def _matvec ( self , x ): self . counter += 1 xx = x . reshape (( self . n_m , self . N , self . n_x )) yy = self . apply ( xx ) if self . addid : yy = xx - yy # preconditioned system return yy . ravel () def apply ( self , \u03c0 , inplace = False ): M_ij = self . M_ij S_ij = self . S_ij n_m = self . n_m N = self . N n_x = self . n_x dumdr = self . dumdr if not inplace : \u03c0 = \u03c0 . copy () return d_filt_dx ( \u03c0 , M_ij , S_ij , n_m , N , n_x , dumdr ) def as_matrix ( self ): arg = np . zeros (( self . n_m , self . N , self . n_x )) larg = arg . ravel () N = len ( larg ) J = numpy . zeros (( N , N )) for i in range ( N ): if i > 0 : larg [ i - 1 ] = 0.0 larg [ i ] = 1.0 J [:, i ] = self . apply ( arg ) . ravel () return J def invert_jac ( res , dres , jres , fut_S , dumdr , tol = 1e-10 , maxit = 1000 , verbose = False ): n_m = res . shape [ 0 ] N = res . shape [ 1 ] n_x = res . shape [ 2 ] err0 = 0.0 ddx = solve_gu ( dres . copy (), res . copy ()) lam = - 1.0 lam_max = - 1.0 err_0 = abs ( ddx ) . max () tot = ddx . copy () if verbose : print ( \"Starting inversion\" ) for nn in range ( maxit ): # operations are made in place in ddx ddx = d_filt_dx ( ddx , jres , fut_S , n_m , N , n_x , dumdr ) err = ( abs ( ddx ) . max ()) lam = err / err_0 lam_max = max ( lam_max , lam ) if verbose : print ( '- {} | {} | {} ' . format ( err , lam , lam_max )) tot += ddx err_0 = err if ( err < tol ): break # tot += ddx*lam/(1-lam) return tot , nn , lam def radius_jac ( res , dres , jres , fut_S , dumdr , tol = 1e-10 , maxit = 1000 , verbose = False ): from numpy import sqrt n_m = res . shape [ 0 ] N = res . shape [ 1 ] n_x = res . shape [ 2 ] err0 = 0.0 norm2 = lambda m : sqrt (( m ** 2 ) . sum ()) import numpy.random \u03c0 = ( numpy . random . random ( res . shape ) * 2 - 1 ) * 1 \u03c0 /= norm2 ( \u03c0 ) verbose = True lam = 1.0 lam_max = 0.0 lambdas = [] if verbose : print ( \"Starting inversion\" ) for nn in range ( maxit ): # operations are made in place in ddx # \u03c0 = (numpy.random.random(res.shape)*2-1)*1 # \u03c0 /= norm2(\u03c0) \u03c0 [:,:,:] /= lam \u03c0 = d_filt_dx ( \u03c0 , jres , fut_S , n_m , N , n_x , dumdr ) lam = norm2 ( \u03c0 ) lam_max = max ( lam_max , lam ) if verbose : print ( '- {} | {} ' . format ( lam , lam_max )) lambdas . append ( lam ) return ( lam , lam_max , lambdas ) from dolo import dprint from .results import AlgoResult , ImprovedTimeIterationResult def improved_time_iteration ( model , method = 'jac' , dr0 = None , dprocess = None , interp_method = 'cubic' , mu = 2 , maxbsteps = 10 , verbose = False , tol = 1e-8 , smaxit = 500 , maxit = 1000 , complementarities = True , compute_radius = False , invmethod = 'iti' , details = True ): def vprint ( * args , ** kwargs ): if verbose : print ( * args , ** kwargs ) itprint = IterationsPrinter ( ( 'N' , int ), ( 'f_x' , float ), ( 'd_x' , float ), ( 'Time_residuals' , float ), ( 'Time_inversion' , float ), ( 'Time_search' , float ), ( 'Lambda_0' , float ), ( 'N_invert' , int ), ( 'N_search' , int ), verbose = verbose ) itprint . print_header ( 'Start Improved Time Iterations.' ) f = model . functions [ 'arbitrage' ] g = model . functions [ 'transition' ] x_lb = model . functions [ 'controls_lb' ] x_ub = model . functions [ 'controls_ub' ] parms = model . calibration [ 'parameters' ] grid , dp = model . discretize () endo_grid = grid [ 'endo' ] exo_grid = grid [ 'exo' ] n_m = max ( dp . n_nodes , 1 ) n_s = len ( model . symbols [ 'states' ]) if interp_method in ( 'cubic' , 'linear' ): ddr = DecisionRule ( dp . grid , endo_grid , dprocess = dp , interp_method = interp_method ) ddr_filt = DecisionRule ( dp . grid , endo_grid , dprocess = dp , interp_method = interp_method ) else : raise Exception ( \"Unsupported interpolation method.\" ) # s = ddr.endo_grid s = endo_grid . nodes N = s . shape [ 0 ] n_x = len ( model . symbols [ 'controls' ]) x0 = model . calibration [ 'controls' ][ None , None ,] . repeat ( n_m , axis = 0 ) . repeat ( N , axis = 1 ) if dr0 is not None : for i_m in range ( n_m ): x0 [ i_m ,:,:] = dr0 . eval_is ( i_m , s ) ddr . set_values ( x0 ) steps = 0.5 ** numpy . arange ( maxbsteps ) lb = x0 . copy () ub = x0 . copy () for i_m in range ( n_m ): m = dp . node ( i_m ) lb [ i_m ,:] = x_lb ( m , s , parms ) ub [ i_m ,:] = x_ub ( m , s , parms ) x = x0 # both affect the precision ddr . set_values ( x ) ## memory allocation n_im = dp . n_inodes ( 0 ) # we assume it is constant for now jres = numpy . zeros (( n_m , n_im , N , n_x , n_x )) S_ij = numpy . zeros (( n_m , n_im , N , n_s )) for it in range ( maxit ): jres [ ... ] = 0.0 S_ij [ ... ] = 0.0 t1 = time . time () # compute derivatives and residuals: # res: residuals # dres: derivatives w.r.t. x # jres: derivatives w.r.t. ~x # fut_S: future states ddr . set_values ( x ) # # ub[ub>100000] = 100000 # lb[lb<-100000] = -100000 # # sh_x = x.shape # rr =euler_residuals(f,g,s,x,ddr,dp,parms, diff=False, with_jres=False,set_dr=True) # print(rr.shape) # # from iti.fb import smooth_ # jj = smooth_(rr, x, lb, ub) # # print(\"Errors with complementarities\") # print(abs(jj.max())) # # exit() # from dolo.numeric.optimize.newton import SerialDifferentiableFunction sh_x = x . shape ff = SerialDifferentiableFunction ( lambda u : euler_residuals ( f , g , s , u . reshape ( sh_x ), ddr , dp , parms , diff = False , with_jres = False , set_dr = False ) . reshape (( - 1 , sh_x [ 2 ])) ) res , dres = ff ( x . reshape (( - 1 , sh_x [ 2 ]))) res = res . reshape ( sh_x ) dres = dres . reshape (( sh_x [ 0 ], sh_x [ 1 ], sh_x [ 2 ], sh_x [ 2 ])) junk , jres , fut_S = euler_residuals ( f , g , s , x , ddr , dp , parms , diff = False , with_jres = True , set_dr = False , jres = jres , S_ij = S_ij ) # if there are complementerities, we modify derivatives if complementarities : res , dres , jres = smooth ( res , dres , jres , x - lb ) res [ ... ] *= - 1 dres [ ... ] *= - 1 jres [ ... ] *= - 1 res , dres , jres = smooth ( res , dres , jres , ub - x , pos =- 1.0 ) res [ ... ] *= - 1 dres [ ... ] *= - 1 jres [ ... ] *= - 1 err_0 = ( abs ( res ) . max ()) # premultiply by A jres [ ... ] *= - 1.0 for i_m in range ( n_m ): for j_m in range ( n_im ): M = jres [ i_m , j_m ,:,:,:] X = dres [ i_m ,:,:,:] . copy () sol = solve_tensor ( X , M ) t2 = time . time () # new version if invmethod == 'gmres' : ddx = solve_gu ( dres . copy (), res . copy ()) L = Operator ( jres , fut_S , ddr_filt ) n0 = L . counter L . addid = True ttol = err_0 / 100 sol = scipy . sparse . linalg . gmres ( L , ddx . ravel (), tol = ttol ) #, maxiter=1, restart=smaxit) lam0 = 0.01 nn = L . counter - n0 tot = sol [ 0 ] . reshape ( ddx . shape ) else : # compute inversion tot , nn , lam0 = invert_jac ( res , dres , jres , fut_S , ddr_filt , tol = tol , maxit = smaxit , verbose = ( verbose == 'full' )) # lam, lam_max, lambdas = radius_jac(res,dres,jres,fut_S,tol=tol,maxit=1000,verbose=(verbose=='full'),filt=ddr_filt) # backsteps t3 = time . time () for i_bckstps , lam in enumerate ( steps ): new_x = x - tot * lam new_err = euler_residuals ( f , g , s , new_x , ddr , dp , parms , diff = False , set_dr = True ) if complementarities : new_err = smooth_nodiff ( new_err , new_x - lb ) new_err = smooth_nodiff ( - new_err , ub - new_x ) new_err = abs ( new_err ) . max () if new_err < err_0 : break err_2 = abs ( tot ) . max () t4 = time . time () itprint . print_iteration ( N = it , f_x = err_0 , d_x = err_2 , Time_residuals = t2 - t1 , Time_inversion = t3 - t2 , Time_search = t4 - t3 , Lambda_0 = lam0 , N_invert = nn , N_search = i_bckstps ) if err_0 < tol : break x = new_x ddr . set_values ( x ) itprint . print_finished () # if compute_radius: # return ddx,L # lam, lam_max, lambdas = radius_jac(res,dres,jres,fut_S,ddr_filt,tol=tol,maxit=smaxit,verbose=(verbose=='full')) # return ddr, lam, lam_max, lambdas # else: if not details : return ddr else : ddx = solve_gu ( dres . copy (), res . copy ()) L = Operator ( jres , fut_S , ddr_filt ) if compute_radius : lam = scipy . sparse . linalg . eigs ( L , k = 1 , return_eigenvectors = False ) lam = abs ( lam [ 0 ]) else : lam = np . nan # lam, lam_max, lambdas = radius_jac(res,dres,jres,fut_S,ddr_filt,tol=tol,maxit=smaxit,verbose=(verbose=='full')) return ImprovedTimeIterationResult ( ddr , it , err_0 , err_2 , err_0 < tol , complementarities , lam , None , L ) def euler_residuals ( f , g , s , x , dr , dp , p_ , diff = True , with_jres = False , set_dr = True , jres = None , S_ij = None ): t1 = time . time () if set_dr : dr . set_values ( x ) N = s . shape [ 0 ] n_s = s . shape [ 1 ] n_x = x . shape [ 2 ] n_ms = max ( dp . n_nodes , 1 ) # number of markov states n_im = dp . n_inodes ( 0 ) res = numpy . zeros_like ( x ) if with_jres : if jres is None : jres = numpy . zeros (( n_ms , n_im , N , n_x , n_x )) if S_ij is None : S_ij = numpy . zeros (( n_ms , n_im , N , n_s )) for i_ms in range ( n_ms ): m_ = dp . node ( i_ms ) xm = x [ i_ms ,:,:] for I_ms in range ( n_im ): M_ = dp . inode ( i_ms , I_ms ) w = dp . iweight ( i_ms , I_ms ) S = g ( m_ , s , xm , M_ , p_ , diff = False ) XM = dr . eval_ijs ( i_ms , I_ms , S ) if with_jres : ff = SerialDifferentiableFunction ( lambda u : f ( m_ , s , xm , M_ , S , u , p_ , diff = False )) rr , rr_XM = ff ( XM ) rr = f ( m_ , s , xm , M_ , S , XM , p_ , diff = False ) jres [ i_ms , I_ms ,:,:,:] = w * rr_XM S_ij [ i_ms , I_ms ,:,:] = S else : rr = f ( m_ , s , xm , M_ , S , XM , p_ , diff = False ) res [ i_ms ,:,:] += w * rr t2 = time . time () if with_jres : return res , jres , S_ij else : return res","title":"dolo.algos.improved_time_iteration"},{"location":"api/source/dolo.algos/","text":"SOURCE CODE dolo. algos DOCS \"\"\"All kinds of algorithms.\"\"\" __author__ = 'pablo' from .commands import *","title":"dolo.algos"},{"location":"api/source/dolo.algos.time_iteration/","text":"SOURCE CODE dolo.algos. time_iteration DOCS \"\"\"Time Iteration Algorithm\"\"\" import numpy from dolo import dprint from dolo.numeric.processes import DiscretizedIIDProcess from dolo.numeric.decision_rule import DecisionRule from dolo.numeric.grids import CartesianGrid def residuals_simple ( f , g , s , x , dr , dprocess , parms ): N = s . shape [ 0 ] n_s = s . shape [ 1 ] res = numpy . zeros_like ( x ) for i_ms in range ( dprocess . n_nodes ): # solving on grid for markov index i_ms m = numpy . tile ( dprocess . node ( i_ms ),( N , 1 )) xm = x [ i_ms ,:,:] for I_ms in range ( dprocess . n_inodes ( i_ms )): M = numpy . tile ( dprocess . inode ( i_ms , I_ms ), ( N , 1 )) prob = dprocess . iweight ( i_ms , I_ms ) S = g ( m , s , xm , M , parms ) XM = dr . eval_ijs ( i_ms , I_ms , S ) rr = f ( m , s , xm , M , S , XM , parms ) res [ i_ms ,:,:] += prob * rr return res from .results import TimeIterationResult , AlgoResult def time_iteration ( model , dr0 = None , with_complementarities = True , DOCS verbose = True , maxit = 1000 , inner_maxit = 10 , tol = 1e-6 , hook = None , details = False , interp_method = 'cubic' ): ''' Finds a global solution for ``model`` using backward time-iteration. This algorithm iterates on the residuals of the arbitrage equations Parameters ---------- model : Model model to be solved verbose : boolean if True, display iterations dr0 : decision rule initial guess for the decision rule with_complementarities : boolean (True) if False, complementarity conditions are ignored maxit: maximum number of iterations inner_maxit: maximum number of iteration for inner solver tol: tolerance criterium for successive approximations hook: Callable function to be called within each iteration, useful for debugging purposes Returns ------- decision rule : approximated solution ''' from dolo import dprint def vprint ( t ): if verbose : print ( t ) grid , dprocess = model . discretize () n_ms = dprocess . n_nodes # number of exogenous states n_mv = dprocess . n_inodes ( 0 ) # this assume number of integration nodes is constant x0 = model . calibration [ 'controls' ] parms = model . calibration [ 'parameters' ] n_x = len ( x0 ) n_s = len ( model . symbols [ 'states' ]) endo_grid = grid [ 'endo' ] exo_grid = grid [ 'exo' ] mdr = DecisionRule ( exo_grid , endo_grid , dprocess = dprocess , interp_method = interp_method ) s = mdr . endo_grid . nodes N = s . shape [ 0 ] controls_0 = numpy . zeros (( n_ms , N , n_x )) if dr0 is None : controls_0 [:, :, :] = x0 [ None , None ,:] else : if isinstance ( dr0 , AlgoResult ): dr0 = dr0 . dr try : for i_m in range ( n_ms ): controls_0 [ i_m , :, :] = dr0 ( i_m , s ) except Exception : for i_m in range ( n_ms ): m = dprocess . node ( i_m ) controls_0 [ i_m , :, :] = dr0 ( m , s ) f = model . functions [ 'arbitrage' ] g = model . functions [ 'transition' ] if 'controls_lb' in model . functions and with_complementarities == True : lb_fun = model . functions [ 'controls_lb' ] ub_fun = model . functions [ 'controls_ub' ] lb = numpy . zeros_like ( controls_0 ) * numpy . nan ub = numpy . zeros_like ( controls_0 ) * numpy . nan for i_m in range ( n_ms ): m = dprocess . node ( i_m )[ None ,:] p = parms [ None ,:] m = numpy . repeat ( m , N , axis = 0 ) p = numpy . repeat ( p , N , axis = 0 ) lb [ i_m ,:,:] = lb_fun ( m , s , p ) ub [ i_m ,:,:] = ub_fun ( m , s , p ) else : with_complementarities = False sh_c = controls_0 . shape controls_0 = controls_0 . reshape ( ( - 1 , n_x ) ) from dolo.numeric.optimize.newton import newton , SerialDifferentiableFunction from dolo.numeric.optimize.ncpsolve import ncpsolve err = 10 it = 0 if with_complementarities : lb = lb . reshape (( - 1 , n_x )) ub = ub . reshape (( - 1 , n_x )) if verbose : headline = '| {0:^4} | {1:10} | {2:8} | {3:8} | {4:3} |' . format ( 'N' , ' Error' , 'Gain' , 'Time' , 'nit' ) stars = '-' * len ( headline ) print ( stars ) print ( headline ) print ( stars ) import time t1 = time . time () err_0 = numpy . nan verbit = ( verbose == 'full' ) while err > tol and it < maxit : it += 1 t_start = time . time () mdr . set_values ( controls_0 . reshape ( sh_c )) fn = lambda x : residuals_simple ( f , g , s , x . reshape ( sh_c ), mdr , dprocess , parms ) . reshape (( - 1 , n_x )) dfn = SerialDifferentiableFunction ( fn ) res = fn ( controls_0 ) if hook : hook () if with_complementarities : [ controls , nit ] = ncpsolve ( dfn , lb , ub , controls_0 , verbose = verbit , maxit = inner_maxit ) else : [ controls , nit ] = newton ( dfn , controls_0 , verbose = verbit , maxit = inner_maxit ) err = abs ( controls - controls_0 ) . max () err_SA = err / err_0 err_0 = err controls_0 = controls t_finish = time . time () elapsed = t_finish - t_start if verbose : print ( '| {0:4} | {1:10.3e} | {2:8.3f} | {3:8.3f} | {4:3} |' . format ( it , err , err_SA , elapsed , nit )) controls_0 = controls . reshape ( sh_c ) mdr . set_values ( controls_0 ) t2 = time . time () if verbose : print ( stars ) print ( \"Elapsed: {} seconds.\" . format ( t2 - t1 )) print ( stars ) if not details : return mdr return TimeIterationResult ( mdr , it , with_complementarities , dprocess , err < tol , # x_converged: bool tol , # x_tol err , #: float None , # log: object # TimeIterationLog None # trace: object #{Nothing,IterationTrace} )","title":"dolo.algos.time_iteration"},{"location":"api/source/dolo.compiler/","text":"SOURCE CODE dolo. compiler DOCS","title":"dolo.compiler"},{"location":"api/source/dolo.compiler.recipes/","text":"SOURCE CODE dolo.compiler. recipes DOCS ''' ideas : - recursive blocks [by default] - (order left hand side ?) [by default] - dependency across blocks - dummy blocks that are basically substituted everywhere else ''' import os , yaml , sys if getattr ( sys , 'frozen' , False ): # we are running in a |PyInstaller| bundle DIR_PATH = sys . _MEIPASS else : DIR_PATH , this_filename = os . path . split ( __file__ ) DATA_PATH = os . path . join ( DIR_PATH , \"recipes.yaml\" ) with open ( DATA_PATH ) as f : recipes = yaml . safe_load ( f )","title":"dolo.compiler.recipes"},{"location":"api/source/dolo/","text":"SOURCE CODE dolo DOCS from dolo.version import __version_info__ , __version__ from dolo.config import * import dolo.compiler.objects import dolo.numeric.processes import dolo.numeric.processes_iid # import dolo.numeric.grids del dolo . compiler . objects del dolo . numeric . processes del dolo . numeric . processes_iid # del dolo.numeric.grids from dolo.compiler.model_import import yaml_import from dolo.misc.display import pcat from dolo.misc.groot import groot from dolo.misc.dprint import dprint from dolo.algos.commands import *","title":"dolo"},{"location":"api/source/dolo.misc/","text":"SOURCE CODE dolo. misc DOCS","title":"dolo.misc"},{"location":"api/source/dolo.misc.termcolor/","text":"SOURCE CODE dolo.misc. termcolor DOCS # coding: utf-8 # Copyright (c) 2008-2011 Volvox Development Team # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # Author: Konstantin Lepa <konstantin.lepa@gmail.com> \"\"\"ANSII Color formatting for output in terminal.\"\"\" from __future__ import print_function import os __ALL__ = [ 'colored' , 'cprint' ] VERSION = ( 1 , 1 , 0 ) ATTRIBUTES = dict ( list ( zip ([ 'bold' , 'dark' , '' , 'underline' , 'blink' , '' , 'reverse' , 'concealed' ], list ( range ( 1 , 9 )) )) ) del ATTRIBUTES [ '' ] HIGHLIGHTS = dict ( list ( zip ([ 'on_grey' , 'on_red' , 'on_green' , 'on_yellow' , 'on_blue' , 'on_magenta' , 'on_cyan' , 'on_white' ], list ( range ( 40 , 48 )) )) ) COLORS = dict ( list ( zip ([ 'grey' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' , ], list ( range ( 30 , 38 )) )) ) RESET = ' \\033 [0m' def colored ( text , color = None , on_color = None , attrs = None ): DOCS \"\"\"Colorize text. Available text colors: red, green, yellow, blue, magenta, cyan, white. Available text highlights: on_red, on_green, on_yellow, on_blue, on_magenta, on_cyan, on_white. Available attributes: bold, dark, underline, blink, reverse, concealed. Example: colored('Hello, World!', 'red', 'on_grey', ['blue', 'blink']) colored('Hello, World!', 'green') \"\"\" if os . getenv ( 'ANSI_COLORS_DISABLED' ) is None : fmt_str = ' \\033 [ %d m %s ' if color is not None : text = fmt_str % ( COLORS [ color ], text ) if on_color is not None : text = fmt_str % ( HIGHLIGHTS [ on_color ], text ) if attrs is not None : for attr in attrs : text = fmt_str % ( ATTRIBUTES [ attr ], text ) text += RESET return text def cprint ( text , color = None , on_color = None , attrs = None , ** kwargs ): DOCS \"\"\"Print colorize text. It accepts arguments of print function. \"\"\" print (( colored ( text , color , on_color , attrs )), ** kwargs ) if __name__ == '__main__' : print ( 'Current terminal type: %s ' % os . getenv ( 'TERM' )) print ( 'Test basic colors:' ) cprint ( 'Grey color' , 'grey' ) cprint ( 'Red color' , 'red' ) cprint ( 'Green color' , 'green' ) cprint ( 'Yellow color' , 'yellow' ) cprint ( 'Blue color' , 'blue' ) cprint ( 'Magenta color' , 'magenta' ) cprint ( 'Cyan color' , 'cyan' ) cprint ( 'White color' , 'white' ) print (( '-' * 78 )) print ( 'Test highlights:' ) cprint ( 'On grey color' , on_color = 'on_grey' ) cprint ( 'On red color' , on_color = 'on_red' ) cprint ( 'On green color' , on_color = 'on_green' ) cprint ( 'On yellow color' , on_color = 'on_yellow' ) cprint ( 'On blue color' , on_color = 'on_blue' ) cprint ( 'On magenta color' , on_color = 'on_magenta' ) cprint ( 'On cyan color' , on_color = 'on_cyan' ) cprint ( 'On white color' , color = 'grey' , on_color = 'on_white' ) print ( '-' * 78 ) print ( 'Test attributes:' ) cprint ( 'Bold grey color' , 'grey' , attrs = [ 'bold' ]) cprint ( 'Dark red color' , 'red' , attrs = [ 'dark' ]) cprint ( 'Underline green color' , 'green' , attrs = [ 'underline' ]) cprint ( 'Blink yellow color' , 'yellow' , attrs = [ 'blink' ]) cprint ( 'Reversed blue color' , 'blue' , attrs = [ 'reverse' ]) cprint ( 'Concealed Magenta color' , 'magenta' , attrs = [ 'concealed' ]) cprint ( 'Bold underline reverse cyan color' , 'cyan' , attrs = [ 'bold' , 'underline' , 'reverse' ]) cprint ( 'Dark blink concealed white color' , 'white' , attrs = [ 'dark' , 'blink' , 'concealed' ]) print (( '-' * 78 )) print ( 'Test mixing:' ) cprint ( 'Underline red on grey color' , 'red' , 'on_grey' , [ 'underline' ]) cprint ( 'Reversed green on red color' , 'green' , 'on_red' , [ 'reverse' ])","title":"dolo.misc.termcolor"},{"location":"api/source/dolo.numeric.discretization.discretization/","text":"SOURCE CODE dolo.numeric.discretization. discretization DOCS \"\"\" Discretization of continuous processes as markov chain \"\"\" import scipy as sp import scipy.stats import numpy as np import math # univariate tauchen code is taken from dpsolve ( https://bitbucket.org/stevejb/dpsolve ) def tauchen ( N , mu , rho , sigma , m = 2 ): DOCS \"\"\" Approximate an AR1 process by a finite markov chain using Tauchen's method. :param N: scalar, number of nodes for Z :param mu: scalar, unconditional mean of process :param rho: scalar :param sigma: scalar, std. dev. of epsilons :param m: max +- std. devs. :returns: Z, N*1 vector, nodes for Z. Zprob, N*N matrix, transition probabilities SJB: This is a port of Martin Floden's 1996 Matlab code to implement Tauchen 1986 Economic Letters method The following comments are Floden's. Finds a Markov chain whose sample paths approximate those of the AR(1) process z(t+1) = (1-rho)*mu + rho * z(t) + eps(t+1) where eps are normal with stddev sigma. \"\"\" Z = np . zeros (( N , 1 )) Zprob = np . zeros (( N , N )) a = ( 1 - rho ) * mu Z [ - 1 ] = m * math . sqrt ( sigma ** 2 / ( 1 - ( rho ** 2 ))) Z [ 0 ] = - 1 * Z [ - 1 ] zstep = ( Z [ - 1 ] - Z [ 0 ]) / ( N - 1 ) for i in range ( 1 , N ): Z [ i ] = Z [ 0 ] + zstep * ( i ) Z = Z + a / ( 1 - rho ) for j in range ( 0 , N ): for k in range ( 0 , N ): if k == 0 : Zprob [ j , k ] = sp . stats . norm . cdf (( Z [ 0 ] - a - rho * Z [ j ] + zstep / 2 ) / sigma ) elif k == ( N - 1 ): Zprob [ j , k ] = 1 - sp . stats . norm . cdf (( Z [ - 1 ] - a - rho * Z [ j ] - zstep / 2 ) / sigma ) else : up = sp . stats . norm . cdf (( Z [ k ] - a - rho * Z [ j ] + zstep / 2 ) / sigma ) down = sp . stats . norm . cdf ( ( Z [ k ] - a - rho * Z [ j ] - zstep / 2 ) / sigma ) Zprob [ j , k ] = up - down return ( ( Z , Zprob ) ) def rouwenhorst ( rho , sigma , N ): DOCS \"\"\" Approximate an AR1 process by a finite markov chain using Rouwenhorst's method. :param rho: autocorrelation of the AR1 process :param sigma: conditional standard deviation of the AR1 process :param N: number of states :return [nodes, P]: equally spaced nodes and transition matrix \"\"\" from numpy import sqrt , linspace , array , zeros sigma = float ( sigma ) if N == 1 : nodes = array ([ 0.0 ]) transitions = array ([[ 1.0 ]]) return [ nodes , transitions ] p = ( rho + 1 ) / 2 q = p nu = sqrt ( ( N - 1 ) / ( 1 - rho ** 2 ) ) * sigma nodes = linspace ( - nu , nu , N ) sig_a = sigma n = 1 # mat0 = array( [[1]] ) mat0 = array ([[ p , 1 - p ],[ 1 - q , q ]]) if N == 2 : return [ nodes , mat0 ] for n in range ( 3 , N + 1 ): mat = zeros ( ( n , n ) ) mat_A = mat . copy () mat_B = mat . copy () mat_C = mat . copy () mat_D = mat . copy () mat_A [: - 1 ,: - 1 ] = mat0 mat_B [: - 1 , 1 :] = mat0 mat_C [ 1 :,: - 1 ] = mat0 mat_D [ 1 :, 1 :] = mat0 mat0 = p * mat_A + ( 1 - p ) * mat_B + ( 1 - q ) * mat_C + q * mat_D mat0 [ 1 : - 1 ,:] = mat0 [ 1 : - 1 ,:] / 2 P = mat0 return [ nodes , P ] def multidimensional_discretization ( rho , sigma , N = 3 , method = 'rouwenhorst' , m = 2 ): DOCS \"\"\" Discretize an VAR(1) into a markov chain. The autoregression matrix is supposed to be a scalar. :param rho: :param sigma: :param N: :param method: :param m: :return: \"\"\" # rho is assumed to be a scalar # sigma is a positive symmetric matrix # N number of points in each non-degenerate dimension # m : standard deviations to approximate import scipy.linalg from itertools import product d = sigma . shape [ 1 ] sigma = sigma . copy () zero_columns = np . where ( sigma . sum ( axis = 0 ) == 0 )[ 0 ] for i in zero_columns : sigma [ i , i ] = 1 L = scipy . linalg . cholesky ( sigma ) N = int ( N ) if method == 'tauchen' : [ nodes_1d , probas_1d ] = tauchen ( N , 0 , rho , 1 , m = m ) elif method == 'rouwenhorst' : [ nodes_1d , probas_1d ] = rouwenhorst ( rho , 1 , N ) markov_nodes = np . array ( list ( product ( * ([ nodes_1d ] * d ))) ) . T markov_indices = np . array ( list ( product ( * ([ range ( N )] * d ) ) ) ) . T markov_nodes = np . dot ( L , markov_nodes ) transition_matrix = 1 for i in range ( d ): transition_matrix = np . kron ( transition_matrix , probas_1d ) markov_nodes = np . ascontiguousarray ( markov_nodes . T ) for i in zero_columns : markov_nodes [:, i ] = 0 return [ markov_nodes , transition_matrix ] def tensor_markov ( * args ): DOCS \"\"\"Computes the product of two independent markov chains. :param m1: a tuple containing the nodes and the transition matrix of the first chain :param m2: a tuple containing the nodes and the transition matrix of the second chain :return: a tuple containing the nodes and the transition matrix of the product chain \"\"\" if len ( args ) > 2 : m1 = args [ 0 ] m2 = args [ 1 ] tail = args [ 2 :] prod = tensor_markov ( m1 , m2 ) return tensor_markov ( prod , * tail ) elif len ( args ) == 2 : m1 , m2 = args n1 , t1 = m1 n2 , t2 = m2 n1 = np . array ( n1 , dtype = float ) n2 = np . array ( n2 , dtype = float ) t1 = np . array ( t1 , dtype = float ) t2 = np . array ( t2 , dtype = float ) assert ( n1 . shape [ 0 ] == t1 . shape [ 0 ] == t1 . shape [ 1 ]) assert ( n2 . shape [ 0 ] == t2 . shape [ 0 ] == t2 . shape [ 1 ]) t = np . kron ( t1 , t2 ) p = t1 . shape [ 0 ] q = t2 . shape [ 0 ] np . tile ( n2 , ( 1 , p )) # n = np.row_stack([ # np.repeat(n1, q, axis=1), # np.tile( n2, (1,p)) # ]) n = np . column_stack ([ np . repeat ( n1 , q , axis = 0 ), np . tile ( n2 , ( p , 1 )) ]) return n , t else : raise Exception ( \"Incorrect number of arguments. Expected at least 2. Found {} .\" . format ( len ( args ))) # # quantization_data = '/home/pablo/quantization_grids/' # # # def quantization_nodes(N,sigma): # import numpy # import numpy.linalg # assert( len(sigma.shape) == 2 ) # var = numpy.diag(sigma) # d = sigma.shape[0] # [w, x] = standard_quantization_weights(N,d ) # A = numpy.linalg.cholesky(sigma) # x = numpy.dot(A, x) # return [x,w] # # # def quantization_weights(N,sigma): # [x,w] = quantization_nodes(N,sigma) # return [w,x] # # def standard_quantization_weights(N,d): # filename = quantization_data + '{0}_{1}_nopti'.format(N,d) # import numpy # # try: # G = numpy.loadtxt(filename) # except Exception as e: # raise e # # w = G[:N,0] # x = G[:N,1:d+1] # # s = numpy.dot(w, x) # x = x - numpy.outer(w,s) # # return [w,x.T] if __name__ == '__main__' : [ Z , Zprob ] = tauchen ( 5 , 0 , 0.8 , 0.1 , 1.5 ) import numpy sigma = numpy . diag ([ 0.1 , 0.1 ]) ** 2 sigma [ 0 , 1 ] = numpy . sqrt ( 0.5 * sigma [ 0 , 0 ] * sigma [ 1 , 1 ] ) sigma [ 1 , 0 ] = numpy . sqrt ( 0.5 * sigma [ 0 , 0 ] * sigma [ 1 , 1 ] ) rho = 0.9 [ nodes , transition ] = multidimensional_discretization ( rho , sigma , 2 , method = 'rouwenhorst' ) transition0 = transition . copy () * 0 transition0 [ 1 , 1 ] = 1.0 print ( nodes . shape ) print ( transition . shape ) [ nodes , transition ] = tensor_markov ( ( nodes , transition0 ), ( nodes , transition ) ) print ( nodes . shape ) print ( transition . shape )","title":"dolo.numeric.discretization.discretization"},{"location":"api/source/dolo.numeric.discretization/","text":"SOURCE CODE dolo.numeric. discretization DOCS __author__ = 'pablo' from .discretization import * from .quadrature import *","title":"dolo.numeric.discretization"}]}